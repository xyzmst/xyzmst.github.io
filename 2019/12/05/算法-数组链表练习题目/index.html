<!DOCTYPE html>
<html lang="zh">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="renderer" content="webkit|ie-comp|ie-stand">
    <meta name="referrer" content="no-referrer">
    <meta name="theme-color" content="#333333">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="google" content="notranslate">
    <meta name="format-detection" content="telephone=no">
    <meta name="keyword"  content="">
    <meta name="description" content="想写什么就写什么">
    <title>算法-数组链表练习题目 - undefined</title>
    <base href="/">
    <link rel="preconnect" href="//cdn.bootcss.com">
    <link rel="manifest" href="/manifest.json">
    <link rel="shortcut icon" href="/icons/icon-72x72.png">
    <link rel="apple-touch-icon" href="/icons/icon-192x192.png">
    <link href="https://cdn.bootcss.com/highlight.js/9.15.10/styles/atom-one-light.min.css" rel="stylesheet">
    <link href="https://cdn.bootcss.com/highlight.js/9.15.10/styles/atom-one-dark.min.css" rel="stylesheet" media="screen and (prefers-color-scheme: dark)">
    <!-- UIkit CSS -->
    <link href="https://cdn.bootcss.com/uikit/3.2.0/css/uikit.min.css" rel="stylesheet">
    <!-- UIkit JS -->
    <script src="https://cdn.bootcss.com/uikit/3.2.0/js/uikit.min.js" async></script>
    <script src="https://cdn.bootcss.com/uikit/3.2.0/js/uikit-icons.min.js" async></script>
    
<link rel="stylesheet" href="/styles/cold-stone.css">

    <noscript>
      <p class="text-center">你的浏览器还没开启 Javascript 功能！</p>
    </noscript>
<meta name="generator" content="Hexo 4.2.0"></head>

  
  <body>
    

    <header class="header" uk-sticky="top: 100; animation: uk-animation-slide-top; bottom: #sticky-on-scroll-up">
  <nav class="wrapper header-content">
    <div class="nav-overlay uk-navbar-left">
      <h1 class="title nav-list-item uk-logo" data-link="/">
        
        <a href="/" data-link="/">xyzmst</a>
        
      </h1>

      <ul class="nav-list">
        
        <li class="nav-list-item" data-link="/categories/">
          <a class="nav-list-link" href="/categories">分类</a>
        </li>
        
        
        <li class="nav-list-item" data-link="/about/">
          <a class="nav-list-link" href="/about/">关于</a>
        </li>
        
        <li class="nav-list-item" data-link="/rss/">
          <a class="nav-list-link" href="/atom.xml">RSS</a>
        </li>
        
      </ul>
    </div>

    
      <div class="uk-navbar-right translate-x">
        <a class="uk-navbar-toggle" href="#modal-full" uk-search-icon uk-toggle></a>
      </div>
    
  </nav>
</header>

<div id="modal-full" class="uk-modal-full uk-modal" uk-modal>
  <div class="uk-modal-dialog uk-flex uk-flex-center uk-flex-middle" uk-height-viewport>
    <button class="uk-modal-close-full" type="button" uk-close></button>
    <form class="uk-search uk-search-large search-form" action="//google.com/search" method="get" accept-charset="UTF-8"
      target="_blank">
      <input class="uk-search-input search-form-input" type="search" name="q" placeholder="搜索"
        autofocus autocomplete="false">
      <input type="hidden" name="sitesearch" value="http://xyzmst.top">
    </form>
  </div>
</div>


    <main class="main wrapper"><article class="article slide-in-right uk-article">
  <section class="article-header">
    <h1 class="article-title uk-article-title">
      算法-数组链表练习题目
    </h1>
    <p class="article-meta uk-article-meta">
      <span class="meta-info">
        <span>
          最后更新&#58;<time class="post-time"
            datetime="2019-12-05">2019-12-05</time>
        </span>
        <span>阅读时间&#58; 9 min</span>
        <span class="hide" id="busuanzi_container_page_pv">阅读量&#58; <span
            id="busuanzi_value_page_pv"></span></span>
      </span>
    </p>
  </section>
  <section class="article-content"><h4 id="移动0"><a href="#移动0" class="headerlink" title="移动0"></a>移动0</h4><p><a href="https://leetcode-cn.com/problems/move-zeroes/submissions/" target="_blank" rel="noopener">letcode 283</a><br>给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。</p>
<p>示例:</p>
<p>输入: [0,1,0,3,12]<br>输出: [1,3,12,0,0]<br>说明:</p>
<p>必须在原数组上操作，不能拷贝额外的数组。<br>尽量减少操作次数。</p>
<h5 id="解法-O-n-一个指针指向非零数字-一层循环遍历"><a href="#解法-O-n-一个指针指向非零数字-一层循环遍历" class="headerlink" title="解法 O(n) 一个指针指向非零数字+一层循环遍历"></a>解法 O(n) 一个指针指向非零数字+一层循环遍历</h5><pre><code>class Solution {
    public void moveZeroes(int[] nums) {
        int j = 0;
        for(int i = 0; i &lt; nums.length; i++){
            if(nums[i] != 0){
                nums[j] = nums[i];
                 if(i != j){
                nums[i] = 0;
            }
            j++;
            }

        }
    }
}</code></pre><h4 id="盛最多水的容器"><a href="#盛最多水的容器" class="headerlink" title="盛最多水的容器"></a>盛最多水的容器</h4><p><a href="https://leetcode-cn.com/problems/container-with-most-water/" target="_blank" rel="noopener">letcode 11</a><br>给定 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。<br>说明：你不能倾斜容器，且 n 的值至少为 2。<br><img src="https://i.loli.net/2020/02/28/lnQDfbeKWoLjAti.png" alt=""></p>
<h6 id="图中垂直线代表输入数组-1-8-6-2-5-4-8-3-7-。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为-49。"><a href="#图中垂直线代表输入数组-1-8-6-2-5-4-8-3-7-。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为-49。" class="headerlink" title="图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。"></a>图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。</h6><p>示例:<br>输入: [1,8,6,2,5,4,8,3,7]<br>输出: 49</p>
<h5 id="解法1-O-n-2-双层循环遍历所有值"><a href="#解法1-O-n-2-双层循环遍历所有值" class="headerlink" title="解法1 O(n^2) 双层循环遍历所有值"></a>解法1 O(n^2) 双层循环遍历所有值</h5><pre><code>class Solution {
    public int maxArea(int[] height) {
        int maxArea = 0;
        //两个变量 i，j 遍历所有的数据
        for(int i = 0; i &lt; height.length - 1; ++i){
            for(int j = i + 1; j &lt; height.length; ++j){
                int area = (j - i)*Math.min(height[i],height[j]);
                maxArea = Math.max(maxArea,area);
            }
        }
        return maxArea;
    }
}</code></pre><h5 id="解法2-O-n-左右边界，同时向中间收敛-又叫-左右夹逼"><a href="#解法2-O-n-左右边界，同时向中间收敛-又叫-左右夹逼" class="headerlink" title="解法2 O(n) 左右边界，同时向中间收敛,又叫 左右夹逼"></a>解法2 O(n) 左右边界，同时向中间收敛,又叫 左右夹逼</h5><pre><code>class Solution {
    public int maxArea(int[] a) {
        int maxArea = 0;
        //一层循环 从两边收敛
        for(int i = 0, j = a.length - 1; i &lt; j;){
            int minHeight = a[i] &lt; a[j] ? a[i++] : a[j--];
            // 上面执行后 会少一个位置
            int area = (j - i + 1)*minHeight;
            maxArea = Math.max(maxArea,area);
        }
        return maxArea;
    }
}

public int maxArea(int[] height) {
    int res = 0;
    int i = 0;
    int j = height.length - 1;
    while (i &lt; j) {
        int area = (j - i) * Math.min(height[i], height[j]);
        res = Math.max(res, area);
        if (height[i] &lt; height[j]) {
            i++;
        } else {
            j--;
        }
    }
    return res;
}

</code></pre><h4 id="爬楼梯"><a href="#爬楼梯" class="headerlink" title="爬楼梯"></a>爬楼梯</h4><p><a href="https://leetcode-cn.com/problems/climbing-stairs" target="_blank" rel="noopener">letcode 70</a><br>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</p>
<p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>
<p>注意：给定 n 是一个正整数。</p>
<p>示例 1：</p>
<p>输入： 2<br>输出： 2<br>解释： 有两种方法可以爬到楼顶。</p>
<ol>
<li>1 阶 + 1 阶</li>
<li>2 阶<br>示例 2：</li>
</ol>
<p>输入： 3<br>输出： 3<br>解释： 有三种方法可以爬到楼顶。</p>
<ol>
<li>1 阶 + 1 阶 + 1 阶</li>
<li>1 阶 + 2 阶</li>
<li>2 阶 + 1 阶</li>
</ol>
<h5 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h5><p>爬上 n-1n−1 阶楼梯的方法数量。因为再爬1阶就能到第n阶<br>爬上 n-2n−2 阶楼梯的方法数量，因为再爬2阶就能到第n阶<br>所以我们得到公式 dp[n] = dp[n-1] + dp[n-2]</p>
<pre><code>class Solution {
    public int climbStairs(int n) {
        int[] dp = new int[n + 1];
        dp[0] = 1;
        dp[1] = 1;
        for(int i = 2; i &lt;= n; i++) {
            dp[i] = dp[i - 1] + dp[i - 2];
        }
        return dp[n];
    }
}
</code></pre><h5 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h5><p><a href="https://leetcode-cn.com/problems/two-sum/" target="_blank" rel="noopener">leetcode 1</a><br>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</p>
<p>示例:</p>
<p>给定 nums = [2, 7, 11, 15], target = 9</p>
<p>因为 nums[0] + nums[1] = 2 + 7 = 9<br>所以返回 [0, 1]</p>
<h5 id="解法-1"><a href="#解法-1" class="headerlink" title="解法"></a>解法</h5><h6 id="方法一：暴力法"><a href="#方法一：暴力法" class="headerlink" title="方法一：暴力法"></a>方法一：暴力法</h6><p>暴力法很简单，遍历每个元素 xx，并查找是否存在一个值与 target - xtarget−x 相等的目标元素</p>
<pre><code>class Solution {
    public int[] twoSum(int[] nums, int target) {
        for (int i = 0; i &lt; nums.length -1; i++) {
            for (int j = i + 1; j &lt; nums.length; j++) {
                if (nums[j] == target - nums[i]) {
                    return new int[] { i, j };
                }
            }
        }
        throw new IllegalArgumentException(&quot;No two sum solution&quot;);
    }
}</code></pre><h6 id="方法二：一遍哈希表"><a href="#方法二：一遍哈希表" class="headerlink" title="方法二：一遍哈希表"></a>方法二：一遍哈希表</h6><pre><code>class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();
        for(int i = 0; i&lt; nums.length; i++) {
            if(map.containsKey(target - nums[i])) {
                return new int[] {map.get(target-nums[i]),i};
            }
            map.put(nums[i], i);
        }
        throw new IllegalArgumentException(&quot;No two sum solution&quot;);
    }
}</code></pre><h4 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a>三数之和</h4><p><a href="https://leetcode-cn.com/problems/3sum" target="_blank" rel="noopener">LeetCode 15</a><br>给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。</p>
<p>注意：答案中不可以包含重复的三元组。</p>
<p>示例：</p>
<p>给定数组 nums = [-1, 0, 1, 2, -1, -4]</p>
<p>满足要求的三元组集合为：<br>[<br>  [-1, 0, 1],<br>  [-1, -1, 2]<br>]</p>
<h5 id="解法-2"><a href="#解法-2" class="headerlink" title="解法"></a>解法</h5><p>1、暴力解法三层循环 O(n^3)<br>2、hash表来记录<br>3、左右下标 推进</p>
<pre><code>//暴力 三层循环 O(n^3) 结果有重复值
    public static List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) {
        List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();
        if (nums.length == 0) {
            return result;
        }
        for (int i = 0; i &lt; nums.length - 2; i++) { // 每个人
            for (int j = i + 1; j &lt; nums.length - 1; j++) { // 依次拉上其他每个人
                for (int k = j + 1; k &lt; nums.length; k++) { // 去问剩下的每个人
                    if (nums[i] + nums[j] + nums[k] == 0) { // 我们是不是可以一起组队
                        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();
                        list.add(nums[i]);
                        list.add(nums[j]);
                        list.add(nums[k]);
                        result.add(list);
                    }
                }
            }
        }
        return result;
    }

    //hash 方式 结果有重复
    public static List&lt;List&lt;Integer&gt;&gt; threeSum2(int[] nums) {

        List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();
        if (nums.length == 0) {
            return result;
        }
        Map&lt;Integer, int[]&gt; map = new HashMap&lt;&gt;();
        for (int i = 0; i &lt; nums.length - 2; i++) { // 每个人
            for (int j = i + 1; j &lt; nums.length - 1; j++) { // 依次拉上其他每个人
                if (map.containsKey(nums[j])) { // 已经有合适自己的两人组
                    List&lt;Integer&gt; list = new ArrayList&lt;&gt;();
                    list.add(nums[j]);
                    list.add(map.get(nums[j])[0]);
                    list.add(map.get(nums[j])[1]);
                    result.add(list);
                } else { // 没有合适自己的两人组
                    int mark = 0 - nums[i] - nums[j];
                    map.put(mark, new int[]{nums[i], nums[j]});
                }
            }
        }
        return result;


    }


    // 双指针
    public static List&lt;List&lt;Integer&gt;&gt; threeSum3(int[] nums) {
        List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();
        if (nums.length == 0) {
            return result;
        }
        //双边需要排序
        Arrays.sort(nums);
        for (int i = 0; i &lt; nums.length; i++) {
            if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) continue;
            int target = -nums[i];
            int left = i + 1;
            int right = nums.length - 1;
            while (left &lt; right) {
                if (nums[left] + nums[right] == target) {
                    List&lt;Integer&gt; list = new ArrayList&lt;&gt;();
                    list.add(nums[i]);
                    list.add(nums[left]);
                    list.add(nums[right]);
                    result.add(list);
                    left++;
                    right--;
                    while (left &lt; nums.length &amp;&amp; nums[left] == nums[left - 1]) left++;
                    while (right &gt; left &amp;&amp; nums[right] == nums[right + 1]) right--;
                } else if (nums[left] + nums[right] &gt; target) {
                    right--;
                } else {
                    left++;
                }

            }
        }
        return result;
    }
</code></pre><h4 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h4><p><a href="https://leetcode-cn.com/problems/reverse-linked-list/solution/fan-zhuan-lian-biao-by-leetcode/" target="_blank" rel="noopener">letcode 206</a><br>反转一个单链表。</p>
<p>示例:</p>
<p>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL<br>输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL<br>进阶:<br>你可以迭代或递归地反转链表。你能否用两种方法解决这道题？</p>
<h5 id="解法-3"><a href="#解法-3" class="headerlink" title="解法"></a>解法</h5><p>1、递归方式 </p>
<pre><code>public ListNode reverseList(ListNode head) {
    if (head == null || head.next == null) return head;
    ListNode p = reverseList(head.next);
    ListNode tmp = head.next;
    tmp.next = head;
    head.next = null;
    return p;
}
</code></pre><p>时间复杂度：O(n)，假设 n 是列表的长度，那么时间复杂度为 O(n)。<br>空间复杂度：O(n)，由于使用递归，将会使用隐式栈空间。递归深度可能会达到 n 层。</p>
<p>2、迭代方式</p>
<pre><code>public ListNode reverseList(ListNode head) {
    ListNode prev = null;
    ListNode curr = head;
    while (curr != null) {
        ListNode nextTemp = curr.next;
        curr.next = prev;
        prev = curr;
        curr = nextTemp;
    }
    return prev;
}
</code></pre><p>时间复杂度：O(n)O(n)，假设 nn 是列表的长度，时间复杂度是 O(n)O(n)。<br>空间复杂度：O(1)O(1)。</p>
<h4 id="环形链表"><a href="#环形链表" class="headerlink" title="环形链表"></a>环形链表</h4><p><a href="https://leetcode-cn.com/problems/linked-list-cycle/" target="_blank" rel="noopener">letcode 141</a></p>
<p>给定一个链表，判断链表中是否有环。<br>为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。</p>
<p>示例 1：输入：head = [3,2,0,-4], pos = 1<br>输出：true<br>解释：链表中有一个环，其尾部连接到第二个节点。<br><img src="https://i.loli.net/2020/03/03/jplMF7h4cDGtXfI.png" alt=""><br>示例 2：输入：head = [1,2], pos = 0<br>输出：true<br>解释：链表中有一个环，其尾部连接到第一个节点。<br><img src="https://i.loli.net/2020/03/03/nsjPLiSCX7K3u9A.png" alt=""><br>示例 3：输入：head = [1], pos = -1<br>输出：false<br>解释：链表中没有环。<br><img src="https://i.loli.net/2020/03/03/dRoOXli79PIe2Zc.png" alt=""><br>进阶：你能用 O(1)（即，常量）内存解决此问题吗？</p>
<h5 id="解法-4"><a href="#解法-4" class="headerlink" title="解法"></a>解法</h5><p>快慢指针</p>
<pre><code>public boolean hasCycle(ListNode head) {
    if (head == null || head.next == null) {
        return false;
    }
    ListNode slow = head;
    ListNode fast = head.next;
    while (slow != fast) {
        if (fast == null || fast.next == null) {
            return false;
        }
        slow = slow.next;
        fast = fast.next.next;
    }
    return true;
}
</code></pre></section>
</article>

<section class="prev-next card slide-in-right">
	
		<a href="/2020/02/17/新世界/" class="link prev" title="新世界">
			<span class="hover-underline-animation">&larr; 新世界</span>
		</a>
	
	
		<a href="/2019/11/28/算法-总览/" class="link next" title="算法-总览">
			<span class="hover-underline-animation">算法-总览 &rarr;</span>
		</a>
	
</section>


<section class="article-toc">
  <div class="card uk-margin-remove-bottom">
    <ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#移动0"><span class="toc-text">移动0</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#解法-O-n-一个指针指向非零数字-一层循环遍历"><span class="toc-text">解法 O(n) 一个指针指向非零数字+一层循环遍历</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#盛最多水的容器"><span class="toc-text">盛最多水的容器</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#图中垂直线代表输入数组-1-8-6-2-5-4-8-3-7-。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为-49。"><span class="toc-text">图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#解法1-O-n-2-双层循环遍历所有值"><span class="toc-text">解法1 O(n^2) 双层循环遍历所有值</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#解法2-O-n-左右边界，同时向中间收敛-又叫-左右夹逼"><span class="toc-text">解法2 O(n) 左右边界，同时向中间收敛,又叫 左右夹逼</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#爬楼梯"><span class="toc-text">爬楼梯</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#解法"><span class="toc-text">解法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#两数之和"><span class="toc-text">两数之和</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#解法-1"><span class="toc-text">解法</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#方法一：暴力法"><span class="toc-text">方法一：暴力法</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#方法二：一遍哈希表"><span class="toc-text">方法二：一遍哈希表</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#三数之和"><span class="toc-text">三数之和</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#解法-2"><span class="toc-text">解法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#反转链表"><span class="toc-text">反转链表</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#解法-3"><span class="toc-text">解法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#环形链表"><span class="toc-text">环形链表</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#解法-4"><span class="toc-text">解法</span></a></li></ol></li></ol>
  </div>
</section>

<section class="article slide-in-right">
  <div class="loader" id="loader">
    <svg viewBox="0 0 50 50">
      <circle class="ring" cx="25" cy="25" r="20"></circle>
      <circle class="ball" cx="25" cy="5" r="3.5"></circle>
    </svg>
  </div>

  <div class="comment" id="utteranc"></div>
  <noscript>Please activate JavaScript for normal use of comments</noscript>
</section>

<a class="card back-to-top" id="backTop">&UpArrow;</a>
</main>

    

    <script>
	window.COLD_STONE = {
		root: "/",
		author: "xyzmst" || '',
		gaid: "xxxxxxxxxxxxxx" || '',
		repo: "xyzmst/blog" || '',
	}
</script>




	<script src="https://cdn.bootcss.com/highlight.js/9.15.10/highlight.min.js"></script>
	<script>hljs.initHighlightingOnLoad()</script>


<script src="/scripts/busuanzi.js" referrerpolicy="origin"></script>

<script src="/scripts/cold-stone.js"></script>



  <script src="//www.googletagmanager.com/gtag/js?id=xxxxxxxxxxxxxx"></script>

  <script>
	window.dataLayer = window.dataLayer || []
	function gtag() {
		dataLayer.push(arguments)
	}
	gtag('js', new Date())
	gtag('config', window.COLD_STONE.gaid)
  </script>


    <!-- <script src="/scripts/hexo_resize_image.js"></script> -->
  </body>
</html>
